<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>sams aura farm simulator 2025 all dlc unlocked real real no cap have a good morning but no cap</title>
<style>
  :root{ --ui-z: 999999; --bg: #000; }
  html,body{ margin:0;height:100%;background:var(--bg);overflow:auto;color:#fff;font-family:system-ui, "Segoe UI", Roboto, Arial; }
  /* keep UI always on top */
  #uiTop { position:fixed; left:0; right:0; top:0; pointer-events:none; z-index:1000000; display:flex; align-items:flex-start; justify-content:center; gap:12px; padding:10px; }
  #auraWrap{ position:relative; width:70%; max-width:1100px; height:34px; background:rgba(255,255,255,0.06); border-radius:18px; padding:4px 10px; box-shadow:0 10px 60px rgba(0,0,0,0.6); }
  #auraLabel{ position:absolute; left:12px; top:-18px; font-size:13px; color:#7ff; text-shadow:0 0 6px #7ff; pointer-events:none; }
  #aura{ height:100%; width:1%; border-radius:14px; background:linear-gradient(90deg,#00f,#0ff,#f0f); box-shadow:0 0 30px rgba(255,255,255,0.06); transition: width 0.18s linear; }
  #titleWrap{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:1000001; pointer-events:none; text-align:center; }
  #bigTitle{ margin:0; font-weight:900; font-size:clamp(20px,8vw,82px); line-height:1; text-shadow:0 12px 40px rgba(0,0,0,0.6); transition: color 0.06s linear, transform 0.06s linear; }
  /* world container holds sam images and cubes and is transformed for spin/zoom */
  #worldWrap{ position:relative; transform-origin:center center; will-change: transform, filter; min-height:160vh; height:160vh; overflow:visible; }
  #world{ position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; }

  /* Sam image elements */
  .sam{ position:absolute; pointer-events:none; user-select:none; will-change:left,top,transform,filter; mix-blend-mode:normal; }

  /* ghost afterimages */
  .ghost{ position:absolute; pointer-events:none; user-select:none; filter: blur(6px) brightness(1.3) saturate(1.5); opacity:0.6; }

  /* overlays and lightning */
  #overlay{ position:fixed; inset:0; pointer-events:none; z-index:900000; mix-blend-mode:screen; }

  .flash{ position:absolute; inset:0; background:var(--c); opacity:0; animation: flashAnim 420ms ease-out forwards; }
  @keyframes flashAnim{ from{opacity:0.95} to{opacity:0} }

  /* chatbot - still on top but clickable */
  #chatbot{ position:fixed; right:16px; bottom:18px; width:280px; z-index:1000002; pointer-events:auto; background:rgba(0,0,0,0.45); color:#cff; border-radius:10px; padding:10px; border:1px solid rgba(255,255,255,0.06); box-shadow:0 10px 40px rgba(0,0,0,0.6); font-size:13px; }
  #chatlog{ max-height:160px; overflow:auto; padding:6px; color:#cfe; }
  #chatInput{ width:100%; padding:8px; margin-top:6px; border-radius:6px; border:none; background:rgba(255,255,255,0.04); color:white; }

  /* cubes - 3D */
  .cubeWrap{ position:absolute; left:50%; top:50%; transform-style:preserve-3d; perspective:1000px; pointer-events:none; }
  .cube{ position:absolute; width:160px; height:160px; transform-style:preserve-3d; transition: transform 0.12s linear; will-change: transform; }
  .face{ position:absolute; width:100%; height:100%; backface-visibility:hidden; background-size:cover; background-position:center; box-shadow:0 6px 20px rgba(0,0,0,0.6); }

  /* warnings / fake errors */
  #warning{ position:fixed; left:50%; top:8%; transform:translateX(-50%); z-index:1000003; display:none; background:rgba(255,40,40,0.95); color:white; padding:10px 18px; border-radius:8px; font-weight:900; box-shadow:0 12px 60px rgba(255,40,40,0.2); }

  #fakeErr{ position:fixed; left:15%; top:12%; transform:translateX(-50%); z-index:1000004; display:none; background:#111; color:#fff; border:3px solid #f00; padding:16px; border-radius:6px; }

  /* jumpscare */
  #jumpscare{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1000005; }
  #jumpscare img{ max-width:120vw; max-height:120vh; filter: drop-shadow(0 0 60px red); }

  /* small helpers */
  .hidden{ display:none !important; }
  .ui-button{ pointer-events:auto; }
</style>

<!-- SVG wobble filter -->
<svg width="0" height="0" style="position:absolute">
  <filter id="wobble">
    <feTurbulence type="fractalNoise" baseFrequency="0.0002" numOctaves="1" result="noise"/>
    <feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G" />
  </filter>
</svg>
</head>
<body>
  <!-- UI always on top -->
  <div id="uiTop">
    <div id="auraWrap">
      <div id="auraLabel">Aura Level</div>
      <div id="aura"></div>
    </div>
  </div>

  <div id="titleWrap">
    <h1 id="bigTitle">sams aura farm simulator 2025 all dlc unlocked real real no cap have a good morning but no cap</h1>
  </div>

  <div id="overlay"></div>
  <div id="warning">AURA OVERFLOW</div>
  <div id="fakeErr">AURA OVERFLOW DETECTED — SYSTEM COMPROMISED</div>
  <div id="jumpscare"></div>

  <div id="chatbot" role="dialog" aria-live="polite">
    <div id="chatlog"><div><b>Chatbot:</b> yes</div></div>
    <input id="chatInput" placeholder="Type..." />
  </div>

  <div id="intro" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#030303,#070707);z-index:1000006;cursor:pointer;">
    <p style="padding:18px;background:rgba(255,255,255,0.03);border-radius:10px;">
      sams aura farm simulator 2025 all dlc unlocked real real no cap have a good morning <b>click to play</b>
    </p>
  </div>

  <!-- world that will be transformed: contains sam images and cubes -->
  <div id="worldWrap">
    <div id="world"></div>
  </div>

<script>
/* MAXIMUM CHAOS - Cube edition
   WARNING: intense flashing, motion, audio.
   Tune MAX_LIVE / MAX_CUBES if your machine struggles.
*/
(() => {
  // --- CONFIG ---
  const IMAGE_SOURCES = [
    'https://sam.pennbrenn.com/sam.png',
    'https://sam.pennbrenn.com/sam1.jpg',
    'https://sam.pennbrenn.com/sam2.jpg',
    'https://sam.pennbrenn.com/sam3.jpg',
    'https://sam.pennbrenn.com/sam4.jpg',
    'https://sam.pennbrenn.com/sam5.jpg'
  ];
  const MAX_LIVE = 700;         // total sam images cap (reduce if laggy)
  const POOL_SIZE = MAX_LIVE + 300;
  const INITIAL_SPAWN = 140;
  const SPAWN_INTERVAL = 1200;  // ms
  const SPAWN_PER_INTERVAL = 40;
  const MAX_CUBES = 12;         // cubes limit
  const CUBE_SIZE_BASE = 140;   // px
  const OVERFLOW_WARNING = 1600;
  const FINAL_AURA = 12000;

  // DOM
  const world = document.getElementById('world');
  const worldWrap = document.getElementById('worldWrap');
  const auraEl = document.getElementById('aura');
  const bigTitle = document.getElementById('bigTitle');
  const overlay = document.getElementById('overlay');
  const warning = document.getElementById('warning');
  const fakeErr = document.getElementById('fakeErr');
  const jumpscareWrap = document.getElementById('jumpscare');
  const chatlog = document.getElementById('chatlog');
  const chatInput = document.getElementById('chatInput');
  const intro = document.getElementById('intro');

  // state pools
  const pool = [];
  const ghostPool = [];
  let active = new Set();
  let ghosts = new Set();
  let cubes = [];
  let started = false;
  let aura = 0;
  let hue = 0;
  let drift = 0;
  let worldAngle = 0;
  let worldScale = 1;
  let finalPhase = false;
  let spawnBurst = SPAWN_PER_INTERVAL;
  let audioCtx = null;
  let humGain = null;
  let lastTick = performance.now();

  // text variants - many mutated versions
  const TITLE_VARIANTS = [
    "sams aura farm simulator 2025 all dlc unlocked real real no cap have a good morning but no cap",
    "sam's aura farm simulator 2025 all dlc unlocked no cap real real have a good morning",
    "sams aura vortex simulator 2025 quantum dlc unlocked no cap real real have a good morning",
    "S A M S  A U R A  F A R M  S I M 2025 — ALL DLC UNLOCKED",
    "sams aura farm simulator 2025 (all dlc unlocked) real real no cap good morning",
    "sams aura farm simulator 2025 /// all dlc unlocked /// real real no cap ///",
    "s.a.f.s. 2025 — all dlc unlocked — real real no cap — have a good morning",
    "SAM'S AURA FARM SIMULATOR 2025 — NO CAP — ALL DLC — HAVE A GOOD MORNING",
    "sɑm's aura farm simulator 2025 all dlc unlocked real real no cap have a good morning",
    "sams aura farm simulator Twenty Twenty-Five - all dlc - real real - no cap"
  ];

  // fonts for crazy switching
  const FONTS = ['Impact','"Comic Sans MS"','"Courier New"','Georgia','"Trebuchet MS"','Verdana','Palatino','serif','monospace'];

  // UTIL
  const rand = (a,b) => Math.random()*(b-a)+a;
  const irand = (a,b) => Math.floor(rand(a,b+1));
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
  function now(){ return performance.now(); }

  // pool init
  function makeSamEl(){
    const img = document.createElement('img');
    img.className = 'sam';
    img.style.display = 'none';
    img.draggable = false;
    img.__alive = false;
    img.__born = 0;
    img.__vx = 0; img.__vy = 0;
    pool.push(img);
    world.appendChild(img);
    return img;
  }
  function makeGhost(){
    const g = document.createElement('img');
    g.className = 'ghost';
    g.style.display = 'none';
    g.draggable = false;
    ghostPool.push(g);
    world.appendChild(g);
    return g;
  }
  for(let i=0;i<POOL_SIZE;i++) makeSamEl();
  for(let i=0;i<120;i++) makeGhost();

  function acquire(){
    const el = pool.find(p=>!p.__alive);
    if(el) return el;
    // if none available create one (limit somewhat)
    if(pool.length < POOL_SIZE*1.5) return makeSamEl();
    return null;
  }
  function acquireGhost(){ return ghostPool.find(g=>g.style.display==='none') || makeGhost(); }

  // spawn at world coords
  function spawnAt(x,y,opts={}){
    const el = acquire();
    if(!el) return null;
    el.src = opts.src || IMAGE_SOURCES[irand(0, IMAGE_SOURCES.length-1)];
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    const scale = opts.scale || rand(1.8,12);
    el.style.width = (40*scale) + 'px';
    el.style.height = (40*scale) + 'px';
    el.style.transform = `rotate(${rand(0,360)}deg)`;
    el.style.filter = `hue-rotate(${irand(0,360)}deg)`;
    el.style.zIndex = irand(1,20000);
    el.__vx = opts.vx !== undefined ? opts.vx : rand(-14,14);
    el.__vy = opts.vy !== undefined ? opts.vy : rand(-14,14);
    el.__alive = true;
    el.__born = Date.now();
    el.style.display = 'block';
    active.add(el);
    return el;
  }

  function spawnRandomInViewport(n){
    const vw = window.innerWidth, vh = window.innerHeight;
    for(let i=0;i<n;i++){
      if(active.size >= MAX_LIVE) break;
      const x = window.scrollX + rand(-vw*0.3, vw*1.3);
      const y = window.scrollY + rand(-vh*0.3, vh*1.3);
      spawnAt(x,y);
    }
  }

  function spawnExplosion(x,y,n){
    for(let i=0;i<n;i++){
      if(active.size >= MAX_LIVE) break;
      spawnAt(x + rand(-40,40), y + rand(-40,40), { vx: rand(-26,26), vy: rand(-26,26), scale: rand(3,16) });
    }
    if(audioCtx) playSpawnSound();
  }

  function retire(el){
    if(!el || !el.__alive) return;
    el.__alive = false;
    el.style.display = 'none';
    active.delete(el);
  }

  function spawnGhostFrom(el){
    const g = acquireGhost();
    g.src = el.src;
    g.style.left = el.style.left;
    g.style.top = el.style.top;
    g.style.width = el.style.width;
    g.style.height = el.style.height;
    g.style.transform = el.style.transform;
    g.style.display = 'block';
    const t0 = Date.now();
    const dur = 1200 + irand(0,1200);
    (function fade(){
      const t = (Date.now() - t0) / dur;
      if(t >= 1){ g.style.display = 'none'; return; }
      g.style.opacity = String(0.6*(1 - t));
      requestAnimationFrame(fade);
    })();
  }

  // physics + attractors + orbit cursor + chatbot repel
  let cursor = {x:window.innerWidth/2, y:window.innerHeight/2, active:false};
  const attractor = { x: window.innerWidth/2 + window.scrollX, y: window.innerHeight/2 + window.scrollY, strength: 0.06 };

  function stepPhysics(dt){
    const vw = window.innerWidth;
    const worldH = document.body.scrollHeight;
    const nowms = Date.now();
    active.forEach(el=>{
      let x = parseFloat(el.style.left) || 0;
      let y = parseFloat(el.style.top) || 0;

      // attractor center
      let dx = (attractor.x + (window.scrollX||0)) - x;
      let dy = (attractor.y + (window.scrollY||0)) - y;
      const d2 = dx*dx + dy*dy + 0.0001;
      const force = attractor.strength * (1e4 / d2);
      el.__vx += dx * force * dt * 60;
      el.__vy += dy * force * dt * 60;

      // orbit to cursor
      if(cursor.active){
        const cdx = cursor.x - x;
        const cdy = cursor.y - y;
        const dist = Math.sqrt(cdx*cdx + cdy*cdy)+0.0001;
        if(dist < 520){
          const perpX = -cdy/dist; const perpY = cdx/dist;
          const orbit = (1 - dist/520)*0.8;
          el.__vx += perpX * orbit * dt * 60;
          el.__vy += perpY * orbit * dt * 60;
          el.__vx += (cdx/dist) * 0.03 * dt * 60;
          el.__vy += (cdy/dist) * 0.03 * dt * 60;
        }
      }

      // chatbot repulsion
      const chatRect = document.getElementById('chatbot').getBoundingClientRect();
      const chatX = chatRect.left + chatRect.width/2 + window.scrollX;
      const chatY = chatRect.top + chatRect.height/2 + window.scrollY;
      const cdx2 = x - chatX; const cdy2 = y - chatY;
      const cd = Math.sqrt(cdx2*cdx2 + cdy2*cdy2);
      if(cd < 260){
        const repel = (260-cd)/260*0.6;
        el.__vx += (cdx2/cd) * repel * dt * 120;
        el.__vy += (cdy2/cd) * repel * dt * 120;
      }

      // integrate
      el.__vx *= 0.995;
      el.__vy *= 0.995;
      x += el.__vx * dt * 60;
      y += el.__vy * dt * 60;

      // bounce
      const w = el.offsetWidth || 40, h = el.offsetHeight || 40;
      if(x < -w){ x = -w; el.__vx *= -0.86; el.__vy *= 0.98; }
      if(x > vw*1.8){ x = vw*1.8; el.__vx *= -0.86; el.__vy *= 0.98; }
      if(y < -h){ y = -h; el.__vy *= -0.86; el.__vx *= 0.98; }
      if(y > worldH){ y = worldH; el.__vy *= -0.86; el.__vx *= 0.98; }

      el.style.left = x+'px';
      el.style.top = y+'px';

      // random ghost trails
      if(Math.random() < 0.001 && nowms - el.__born > 400){
        spawnGhostFrom(el);
      }
      // retire very old elements to recycle
      if(nowms - el.__born > 1200*1000){
        retire(el);
      }
    });
  }

  // WORLD: camera drift, zoom breathing, wobble with svg filter
  let lastFrame = performance.now();
  let driftT = 0;
  function animateWorld(){
    const t = performance.now();
    const dt = (t - lastFrame)/1000;
    lastFrame = t;
    driftT += dt;
    const panX = Math.sin(driftT*0.14)*16;
    const panY = Math.sin(driftT*0.09)*10;
    worldAngle = (worldAngle + (finalPhase?1.2:0.35)) % 360;
    worldScale = 1 + Math.sin(driftT*0.7)*0.024 + (finalPhase?0.08*Math.sin(driftT*4):0);
    worldWrap.style.transform = `translate(${panX}px,${panY}px) rotate(${worldAngle/10}deg) scale(${worldScale})`;
    // wobble filter
    const turb = document.querySelector('filter feTurbulence');
    if(turb) turb.setAttribute('baseFrequency', String(0.0002 + Math.abs(Math.sin(driftT*0.6))*0.0016));
    document.querySelector('filter feDisplacementMap').setAttribute('scale', String(2 + Math.abs(Math.sin(driftT))*10 * (finalPhase?3:1)));
    // hue rotate global
    hue = (hue + (finalPhase?6:1.8)) % 360;
    document.documentElement.style.filter = `hue-rotate(${hue}deg) saturate(${finalPhase?1.6:1})`;
    // title colour pulse
    bigTitle.style.color = `hsl(${(aura/5)%360} 95% 60%)`;
    if(aura > OVERFLOW_WARNING){
      bigTitle.style.transform = `scale(${1 + 0.02*Math.sin(driftT*10)}) rotate(${Math.sin(driftT*6)*2}deg)`;
    } else {
      bigTitle.style.transform = 'scale(1) rotate(0deg)';
    }
    // physics step
    stepPhysics(dt);
    requestAnimationFrame(animateWorld);
  }

  // overlay lightning flash
  function lightning(color){
    const el = document.createElement('div');
    el.className = 'flash';
    el.style.setProperty('--c', color || `hsl(${irand(0,359)} 100% 60%)`);
    overlay.appendChild(el);
    setTimeout(()=>{ try{ overlay.removeChild(el);}catch(e){} }, 800);
  }

  // screen shake helper
  let shaking = false;
  function shake(intensity=18, duration=450){
    if(shaking) return;
    shaking = true;
    const start = Date.now();
    const orig = document.documentElement.style.transform || '';
    (function tick(){
      const dt = Date.now() - start;
      if(dt > duration){ document.documentElement.style.transform = orig; shaking=false; return; }
      const mag = intensity * (1 - dt/duration);
      document.documentElement.style.transform = `translate(${irand(-mag,mag)}px,${irand(-mag,mag)}px) rotate(${irand(-mag/2,mag/2)}deg)`;
      requestAnimationFrame(tick);
    })();
    setTimeout(()=>{ document.documentElement.style.transform = orig; shaking=false; }, duration+80);
  }

  // solar flare
  function solarFlare(){
    worldWrap.style.transition = 'filter 240ms ease, transform 240ms ease';
    worldWrap.style.filter = 'brightness(2.6) blur(3px) saturate(1.6)';
    setTimeout(()=> { worldWrap.style.filter=''; }, 420 + irand(0,800));
  }

  // aura overflow warning
  function flashWarning(){
    warning.style.display = 'block';
    let t = 0;
    const id = setInterval(()=>{ warning.style.opacity = String((Math.sin(t*3)+1)/2*0.9 + 0.05); t+=0.25; }, 90);
    setTimeout(()=>{ clearInterval(id); warning.style.display='none'; }, 3000);
  }
  function fakeError(){
    fakeErr.style.display = 'block';
    setTimeout(()=> fakeErr.style.display='none', 2300 + irand(0,2000));
  }

  // AUDIO: Web Audio hum + spawn + scream
  function initAudio(){
    if(audioCtx) return;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass'; lp.frequency.value = 1200;
      osc.type = 'sine'; osc.frequency.value = 56;
      gain.gain.value = 0.00005;
      osc.connect(lp); lp.connect(gain); gain.connect(audioCtx.destination);
      osc.start();
      humGain = gain;
    }catch(e){ console.warn('Audio failed', e); }
  }
  function setHum(){
    if(!humGain) return;
    const g = clamp(aura / 12000, 0.0002, 0.6);
    try{ humGain.gain.linearRampToValueAtTime(g*0.02, audioCtx.currentTime + 0.06); }catch(e){}
  }
  function playSpawnSound(){
    if(!audioCtx) return;
    const ctx = audioCtx;
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sawtooth'; o.frequency.value = rand(120,900); g.gain.value = 0.0008;
    o.connect(g); g.connect(ctx.destination); o.start();
    g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.16);
    o.stop(ctx.currentTime + 0.2);
  }
  function playScream(){
    if(!audioCtx) return;
    const ctx = audioCtx;
    const bufferSize = 2 * ctx.sampleRate;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/bufferSize*3);
    const src = ctx.createBufferSource(); src.buffer = buffer;
    const g = ctx.createGain(); g.gain.value = 0.6;
    const bi = ctx.createBiquadFilter(); bi.type='highpass'; bi.frequency.value = 200;
    src.connect(g); g.connect(bi); bi.connect(ctx.destination);
    src.start();
    setTimeout(()=>{ try{ src.stop(); }catch(e){} }, 600 + irand(0,400));
  }

  // jumpscare
  function leapscare(){
    const img = document.createElement('img');
    img.src = IMAGE_SOURCES[irand(0, IMAGE_SOURCES.length-1)];
    jumpscareWrap.innerHTML = '';
    jumpscareWrap.appendChild(img);
    jumpscareWrap.style.display = 'flex';
    playScream();
    spawnGhosts(6);
    shake(42, 700);
    solarFlare();
    setTimeout(()=> { jumpscareWrap.style.display = 'none'; }, 700 + irand(0,700));
  }

  // spawn ghosts from a few active sam images
  function spawnGhosts(n){
    const arr = Array.from(active);
    for(let i=0;i<n;i++){
      if(arr.length===0) break;
      const s = arr[irand(0, arr.length-1)];
      if(s) spawnGhostFrom(s);
    }
  }

  // Chatbot evolution & triggers
  const memory = { count: 0, learned: {} };
  const baseReplies = ['yes','yep','absolutely','indeed','yes (aura rising)','real real yes','affirmative'];

  function botReply(text){
    memory.count++;
    text.split(/\s+/).forEach(w=>{
      const word = w.toLowerCase().replace(/[^a-z0-9]/g,'');
      if(!word) return;
      memory.learned[word] = (memory.learned[word]||0)+1;
    });
    // summon words
    const summon = ['summon','more','spawn','sam','aura','yes','rain'];
    for(const s of summon) if(text.toLowerCase().includes(s)) { spawnRandomInViewport(14 + irand(2,18)); if(audioCtx) playSpawnSound(); }

    const replies = baseReplies.slice();
    if(memory.count > 24) replies.push('i have learned to say yes more');
    if(aura > OVERFLOW_WARNING) replies.push('YESYESYESYES'); // panic
    if(Math.random()<0.08) replies.push('chatbot is vibrating');
    if(Object.keys(memory.learned).length>0){
      const k = Object.keys(memory.learned)[irand(0, Object.keys(memory.learned).length-1)];
      if(k) replies.push('yes about ' + k);
    }
    const r = replies[irand(0,replies.length-1)];
    chatlog.innerHTML += `<div><b>Chatbot:</b> ${r}</div>`;
    chatlog.scrollTop = chatlog.scrollHeight;
    // speech
    if('speechSynthesis' in window && Math.random() < 0.14){
      const u = new SpeechSynthesisUtterance('yes'); u.volume = 0.05 + Math.random()*0.25; u.rate = 0.6+Math.random()*0.9; u.pitch = 0.2+Math.random()*1.4; speechSynthesis.speak(u);
    }
    // interrupt occasionally
    if(Math.random() < 0.05) setTimeout(()=> { chatlog.innerHTML += `<div><b>Chatbot:</b> ${['vibrating','aura intensifies'][irand(0,1)]}</div>`; chatlog.scrollTop = chatlog.scrollHeight; }, irand(300,1200));
  }

  // message input handler
  document.getElementById('chatInput').addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){ const t = e.target.value.trim(); if(t.length){ chatlog.innerHTML += `<div><b>You:</b> ${t}</div>`; e.target.value=''; setTimeout(()=> botReply(t), irand(200,900)); } }
  });

  // periodic bot interrupts
  setInterval(()=>{ if(!started) return; if(Math.random()<0.07) { chatlog.innerHTML += `<div><b>Chatbot:</b> ${['yes','real real yes','vibrating'][irand(0,2)]}</div>`; chatlog.scrollTop = chatlog.scrollHeight; } }, 4200);

  // user triggers
  window.addEventListener('click', (ev)=>{ if(!started) return; spawnExplosion(ev.pageX, ev.pageY, 26+irand(8,28)); document.querySelector('filter feDisplacementMap').setAttribute('scale', String(16+irand(0,48))); setTimeout(()=> document.querySelector('filter feDisplacementMap').setAttribute('scale','3'), 360); }, {passive:true});
  window.addEventListener('scroll', ()=>{ if(!started) return; worldWrap.style.transition='transform 420ms ease'; worldWrap.style.transform += ` rotate(${irand(-8,8)}deg)`; spawnRandomInViewport(8+irand(0,16)); if(audioCtx) playSpawnSound(); setTimeout(()=> worldWrap.style.transition='', 640); }, {passive:true});
  window.addEventListener('mousemove', (e)=>{ cursor.x = e.pageX; cursor.y = e.pageY; cursor.active = true; });

  // keypress triggers
  window.addEventListener('keydown', (e)=>{ if(!started) return; if(e.key === ' ') { spawnRandomInViewport(36); lightning(`hsl(${irand(0,359)} 100% 60%)`); if(audioCtx) playSpawnSound(); } else { bigTitle.style.fontFamily = FONTS[irand(0,FONTS.length-1)]; hue = (hue + irand(20,160)) % 360; document.documentElement.style.filter = `hue-rotate(${hue}deg)`; } });

  // cubes: create 3D cube element with faces populated by sam images
  function createCube(x,y,size){
    const wrap = document.createElement('div');
    wrap.className = 'cubeWrap';
    wrap.style.left = x + 'px';
    wrap.style.top = y + 'px';
    wrap.style.width = size + 'px';
    wrap.style.height = size + 'px';
    wrap.style.marginLeft = -(size/2) + 'px';
    wrap.style.marginTop = -(size/2) + 'px';
    wrap.style.perspective = (size*3) + 'px';
    const cube = document.createElement('div');
    cube.className = 'cube';
    cube.style.width = size + 'px';
    cube.style.height = size + 'px';
    wrap.appendChild(cube);
    // faces
    const faces = [];
    for(let i=0;i<6;i++){
      const f = document.createElement('div'); f.className='face';
      f.style.width = size + 'px'; f.style.height = size + 'px';
      f.style.backgroundImage = `url(${IMAGE_SOURCES[irand(0,IMAGE_SOURCES.length-1)]})`;
      cube.appendChild(f);
      faces.push(f);
    }
    // position faces (CSS 3D)
    faces[0].style.transform = `rotateY(0deg) translateZ(${size/2}px)`; // front
    faces[1].style.transform = `rotateY(180deg) translateZ(${size/2}px)`; // back
    faces[2].style.transform = `rotateY(90deg) translateZ(${size/2}px)`; // right
    faces[3].style.transform = `rotateY(-90deg) translateZ(${size/2}px)`; // left
    faces[4].style.transform = `rotateX(90deg) translateZ(${size/2}px)`; // top
    faces[5].style.transform = `rotateX(-90deg) translateZ(${size/2}px)`; // bottom
    // attach wrapper to world
    world.appendChild(wrap);
    const cubeObj = { wrap, cube, size, vx: rand(-0.8,0.8), vy: rand(-0.8,0.8), vz: rand(-1.8,1.8), ang: rand(0,360), spin: rand(0.3,1.6) };
    cubes.push(cubeObj);
    return cubeObj;
  }

  // update cubes (float, rotate, clone occasionally)
  function stepCubes(dt){
    const vw = window.innerWidth;
    for(let i=cubes.length-1;i>=0;i--){
      const c = cubes[i];
      // float
      const left = parseFloat(c.wrap.style.left) || 0;
      const top = parseFloat(c.wrap.style.top) || 0;
      const nx = left + c.vx * dt * 60;
      const ny = top + c.vy * dt * 60;
      c.wrap.style.left = nx + 'px';
      c.wrap.style.top = ny + 'px';
      // spin 3D
      c.ang = (c.ang + c.spin*dt*80) % 360;
      c.cube.style.transform = `rotateX(${c.vz*40}deg) rotateY(${c.ang}deg) translateZ(0px)`;
      // occasional clone or explode
      if(Math.random() < 0.002 && cubes.length < MAX_CUBES){
        // spawn new cube nearby
        createCube(nx + rand(-200,200), ny + rand(-200,200), clamp(c.size*(0.6+Math.random()*0.8), 80, 420));
      }
      if(Math.random() < 0.0015){
        // explode into sam images
        const count = irand(8,28);
        for(let j=0;j<count;j++){
          spawnAt(nx + rand(-c.size/2, c.size/2), ny + rand(-c.size/2, c.size/2), { vx: rand(-36,36), vy: rand(-36,36), scale: rand(3,16) });
        }
        if(audioCtx) playScream();
      }
      // remove if too far or too many cubes
      const centerX = window.scrollX + vw/2;
      if(cubes.length > MAX_CUBES*1.4){
        // prune some
        const rem = cubes.shift();
        if(rem){ rem.wrap.remove(); }
      }
    }
  }

  // main tick
  let last = performance.now();
  function tick(){
    const t = performance.now();
    const dt = (t - last)/1000;
    last = t;
    // physics step already handled in animateWorld; but we need cubes movement too
    stepCubes(dt);
    // retire some if too many active images
    if(active.size > MAX_LIVE){
      const arr = Array.from(active);
      for(let i=0;i< Math.min(60, active.size - MAX_LIVE); i++){
        retire(arr[i]);
      }
    }
    requestAnimationFrame(tick);
  }

  // aura tick - grows endlessly and triggers events
  function auraTick(){
    if(!started) return;
    aura += (active.size * 0.08) + rand(0,4) + (cubes.length * 3.2);
    auraEl.style.width = (Math.min(aura, 99999999)) + '%';
    // spill particles sometimes
    if(aura > 120 && Math.random() < 0.07){
      const s = document.createElement('div');
      s.className = 'aura-spill';
      s.style.left = (window.innerWidth*0.5 + irand(-120,120)) + 'px';
      s.style.top = '6px';
      s.style.background = `hsl(${aura%360} 100% 60%)`;
      s.style.zIndex = 1000000;
      document.getElementById('auraWrap').appendChild(s);
      setTimeout(()=> s.remove(), 3200);
    }
    if(aura > OVERFLOW_WARNING && Math.random() < 0.02){
      flashWarning();
      corruptTitle();
      playScream();
      shake(36, 650);
    }
    if(aura > FINAL_AURA && !finalPhase){
      finalPhase = true;
      // final mode: heavy rains and strobe
      setInterval(()=> spawnRandomInViewport(120), 420);
      setInterval(()=> { document.documentElement.style.filter = `invert(${Math.random()<0.5?1:0})`; }, 900);
      lightning('white');
    }
    setHum();
    requestAnimationFrame(auraTick);
  }

  // spawning interval
  function startSpawner(){
    setInterval(()=>{
      if(!started) return;
      spawnRandomInViewport(spawnBurst);
      if(Math.random() < 0.2) lightning(`hsl(${irand(0,359)} 100% 64%)`);
      if(Math.random() < 0.12) solarFlare();
      if(Math.random() < 0.03) leapscare();
      if(Math.random() < 0.5 && audioCtx) playSpawnSound();
    }, SPAWN_INTERVAL);
  }

  // corrupt title (text glitch)
  function corruptTitle(){
    const orig = TITLE_VARIANTS[irand(0, TITLE_VARIANTS.length-1)];
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=-[]{};:<>?,./';
    let t = 0;
    const id = setInterval(()=>{
      let s = '';
      for(let i=0;i<orig.length;i++){
        if(Math.random() < 0.22) s += chars[irand(0, chars.length-1)];
        else s += orig[i];
      }
      bigTitle.textContent = s;
      t++;
      if(t > 10){ clearInterval(id); bigTitle.textContent = TITLE_VARIANTS[irand(0, TITLE_VARIANTS.length-1)]; }
    }, 60);
  }

  // continuously morph title variants & fonts fast
  setInterval(()=> {
    if(!started) return;
    bigTitle.textContent = TITLE_VARIANTS[irand(0, TITLE_VARIANTS.length-1)];
    bigTitle.style.fontFamily = FONTS[irand(0,FONTS.length-1)];
    bigTitle.style.color = `hsl(${irand(0,359)} 90% 60%)`;
  }, 120);

  // cube creation: spawn a few initially
  function warmCubes(){
    for(let i=0;i<6;i++){
      const x = window.scrollX + window.innerWidth * rand(0.2,0.8);
      const y = window.scrollY + window.innerHeight * rand(0.2,0.8);
      createCube(x,y, CUBE_SIZE_BASE * rand(0.6,2.4));
    }
  }

  // create "big cube" centered behind the title
  function createHeroCube(){
    const rect = document.getElementById('titleWrap').getBoundingClientRect();
    const cx = window.scrollX + rect.left + rect.width/2;
    const cy = window.scrollY + rect.top + rect.height/2;
    const size = Math.min(window.innerWidth, window.innerHeight) * 0.6;
    createCube(cx, cy, clamp(size, 180, 900));
  }

  // boot sequence
  function start(){
    if(started) return;
    started = true;
    initAudio();
    aura = 0;
    // initial spawn
    spawnRandomInViewport(INITIAL_SPAWN);
    // cubes
    warmCubes();
    createHeroCube();
    // animate loops
    lastTick = performance.now();
    requestAnimationFrame(animateWorld);
    requestAnimationFrame(tick);
    requestAnimationFrame(auraTick);
    startSpawner();
    // ramp spawn burst gradually
    setInterval(()=> { spawnBurst = Math.min(spawnBurst + 1, 280); }, 25*1000);
    // periodic random effects
    setInterval(()=> { if(Math.random() < 0.25) lightning(`hsl(${irand(0,359)} 100% 64%)`); if(Math.random()<0.06) solarFlare(); if(Math.random()<0.02) leapscare(); }, 1400);
    // escalate auto-reload-ish effect
    setInterval(()=> {
      if(Math.random() < 0.04) { fakeErr.style.display = 'block'; setTimeout(()=> fakeErr.style.display='none', 2400); }
      if(Math.random() < 0.03 && Math.random() < 0.07) location.reload();
    }, 30*1000);
    // developer hook - small cleanup
    setInterval(()=> {
      if(active.size > MAX_LIVE){
        const arr = Array.from(active);
        for(let i=0;i< Math.min(80, active.size - MAX_LIVE); i++) retire(arr[i]);
      }
    }, 1200);
  }

  // initial event wiring & start on click/touch/keypress
  intro.addEventListener('click', ()=> { intro.style.display='none'; start(); }, { once:true });
  document.addEventListener('keydown', ()=> start(), { once:true });
  window.addEventListener('touchstart', ()=> start(), { once:true });

  // responsive: reposition attractor center on resize/scroll
  window.addEventListener('resize', ()=> { attractor.x = window.innerWidth/2; attractor.y = window.innerHeight/2; });
  window.addEventListener('scroll', ()=> { attractor.x = window.innerWidth/2; attractor.y = window.innerHeight/2; });

  // small helper functions exposure for debugging in console
  window.__samChaos = {
    spawnRandomInViewport,
    spawnExplosion,
    createCube,
    leapscare,
    countActive: ()=> active.size,
    auraValue: ()=> aura
  };

  // pre-warm by setting a hero title variant
  bigTitle.textContent = TITLE_VARIANTS[0];

})();
</script>
</body>
</html>
